//
//  main.c
//  Algorithm_6_2
//
//  Created by sdx on 2018/6/13.
//  Copyright © 2018年 sdx. All rights reserved.
//  最短路径

#include <stdio.h>

int main(int argc, const char * argv[]) {
    // insert code here...
    printf("Hello, World!\n");
    
#pragma mark-- Bellman-Ford 解决负边权（单源最短路径）
    /**
    再求单源最短路径中 dijkstra 算法虽然好，但是不能解决负权边（边的权值为负数的，两个点之间的距离是负数，负方向）的图 Bellman-Ford 算法可以完美的解决负边权问题
     ------------------> 以箭头为正方向
     A        B        C
     有订点 A B C，顶点 A和B相距 50， 和C相距100，那么 A-->B 为 50， B-->A 就是 -50
     
     问题是 这样的 有n个点， m 条边
     Bellman-Ford 核心思想 ： 对所有的边进行 n - 1 次 “松弛” 操作， 为什么是 n - 1呢，其实是这样的，因为有n个点，那么一个点到其他店最短距离的一共只有 n - 1 条，还有在最坏的情况下，需要 n-1 次才计算出最短路径，一般都不需要 n -1 次那么多
     */
    
    
    /***
    // 用于存储地图 {a,b,c}  a ，b 是顶点编号 c是 a到b的距离
    int map[5][3] = {
        {1,2,2},
        {0,1,-3},
        {0,4,5},
        {3,4,2},
        {2,3,3}
    };
    // dis[10] 用于存储 0号顶点其他到每个点的最短距离
    // u[10] : 存储顶点编号  v[10]:存储顶点编号  w[10]:存储编号u[i] --> v[i] 权值（就是这两个顶点的距离）
    int dis[10],i,j,k,n,m,u[10],v[10],w[10];
    int inf = 99999999; // 代表无穷大
    printf("读入顶点n 和边数m：");
    scanf("%d %d",&n,&m); // 5 个顶点, 5条边
    
    // 读入边
    for (i = 0; i < m; i ++) {
        //printf("输入两个顶点 和他们之间的距离");
        //scanf("%d %d %d",&u[i],&v[i],&w[i]);
        // 不想输入
        for (j = 0; j < 3; j ++) {
            if (j == 0) {
                u[i] = map[i][0];
            }
            if (j == 1) {
                v[i] = map[i][1];
            }
            if (j == 2) {
                w[i] = map[i][2];
            }
        }
        printf("%d %d %d \n",u[i],v[i],w[i]);
    }
    
    // 初始化dis 数组，这里是0号顶点到其他点之间的距离
    for (i = 0; i < n; i ++) {
        dis[i] = inf; // 设置到其他点的初始距离都是无穷大
    }
    dis[0] = 0; // 设置0号点到0号点之间的距离是0
    

    
    // Bellman-Ford算法核心语句
    for (k = 0; k < n - 1; k ++) {
        for (i = 0; i < m; i ++) {
            if (dis[v[i]] > dis[u[i]] + w[i]) {
                dis[v[i]] = dis[u[i]]  + w[i];
            }
        }
    }
    

    // 打印最终结果
    printf("最终结果是：\n");
    for (i = 0; i < n; i ++) {
        printf("%d ",dis[i]);
    }
    printf("\n");
    getchar();
     **/
#pragma mark-- Bellman-Ford 解决负边权- 优化1（单源最短路径）
    /**
     Bellman-Ford 的算法时间复杂度是 O(M*N) ,这个时间复杂度比 Dijkstra 的复杂度还高，
     但是实际上 Bellman-Ford 经常会在没有到达 n - 1 轮的时候已经j计算出来最短路径，所以，我们可以对他进行相应的优化
     
     Bellman-Ford检测负权回路 ：实际情况下，一个图在没有“负权回路”的时候，那么最短路径所包含的边·最多有 n-1 条，也就是在n-1轮松弛之后最短路径不会发生改变， 在 n - 1 次结束的时候最短路径还会发生变化，那么改图必然有负权回路
     
     负权回路：
     如果存在一个环（从某个点出发又回到自己的路径），而且这个环上所有权值之和是负数，那这就是一个负权环，也叫负权回路
     存在负权回路的图是不能求两点间最短路的，因为只要在负权回路上不断兜圈子，所得的最短路长度可以任意小。
     **/
    
    
    // 用于存储地图 {a,b,c}  a ，b 是顶点编号 c是 a到b的距离
   
    /***
    int map[5][3] = {
        {1,2,2},
        {0,1,-3},
        {0,4,5},
        {3,4,2},
        {2,3,3}
    };
    int dis[10],bak[10],i,j,k,n,m,u[10],v[10],w[10],cheak,flag;
    int inf = 99999999; // 代表无穷大
    printf("读入顶点n 和边数m：");
    scanf("%d %d",&n,&m); // 5 个顶点, 5条边
    
    // 读入边
    for (i = 0; i < m; i ++) {
        //printf("输入两个顶点 和他们之间的距离");
        //scanf("%d %d %d",&u[i],&v[i],&w[i]);
        // 不想输入
        for (j = 0; j < 3; j ++) {
            if (j == 0) {
                u[i] = map[i][0];
            }
            if (j == 1) {
                v[i] = map[i][1];
            }
            if (j == 2) {
                w[i] = map[i][2];
            }
        }
        printf("%d %d %d \n",u[i],v[i],w[i]);
    }
    
    // 初始化dis 数组，这里是0号顶点到其他点之间的距离
    for (i = 0; i < n; i ++) {
        dis[i] = inf; // 设置到其他点的初始距离都是无穷大
    }
    dis[0] = 0; // 设置0号点到0号点之间的距离是0
    
    // Bellman-Ford算法核心语句
    for (k = 0; k < n - 1; k ++) {
        
        // 将 dis 数组备份到 bak 数组
        for (i = 0; i < n; i ++) {
            bak[i] = dis[i];
        }
        
        // 进行一轮松弛
        for (i = 0; i < m; i ++) {
            if (dis[v[i]] > dis[u[i]] + w[i]) {
                dis[v[i]] = dis[u[i]] + w[i];
            }
        }
        
        // 松弛完毕后检查dis数组是否有更新
        cheak = 0;
        for (i = 0; i < n; i ++) {
            if (bak[i] != dis[i]) {
                cheak = 1;
                break ;
            }
        }
        if (cheak == 0) {
            break;  // 如果dis数组没有更新，提前退出循环
        }
        
    }
    
    
    // 检测负权回路
    flag = 0;
    for (i = 0; i < m; i ++) {
        if (dis[v[i]] > dis[u[i]] + w[i]) {
            flag = 1;
        }
    }
    
    if (flag == 1) {
        printf("此图片含有负权回路");
    } else
    {
        printf("最终结果是：");
        for (i = 0; i < n; i ++) {
            printf("%d ",dis[i]);
        }
        printf("\n");
    }
    
    getchar();
     ***/
    
    
#pragma mark -- Bellman-Ford 的队列优化
    
    /**
     在上一个demo 里面，Bellman-Ford 算法的优化方式：每次仅对最短路程发生变化了的相邻边执行松弛操作，但是如何提前知道当前哪些点的最短路程发生了改变，这里可以使用队列来维护这些点，算法大致如下
     
     每次选取队首顶点u，对顶点u的所有出边进行松弛操作。列如有一条u->v这条边，使得源点到顶点v的最短路程变短
     （dis[u] + e[u][v] < dis[v] Dijkstra 算法里面学过），且顶点v不在当前队列，就将顶点v放入队尾。需要注意的是，同一个顶点只需要在队列出现一次，所以我们这里需要一个 book[n]数组来记录是否已经在队列里面，在对顶点u的所有边松弛完毕之后，就将顶点v出队，接下来不断从队列中取出新的队首顶点在进行如上操作，直至队列为空为止。
     
     这次使用“邻接表”（Dijkstra 里面学过）来存储图数据 （邻接表相对比邻接矩阵可以降低时间复杂度）
     **/
    
    // 用于存储地图 {a,b,c}  a ，b 是顶点编号 c是 a到b的距离
    int map[7][3] = {
        {0,1,2},
        {0,4,10},
        {1,2,3},
        {1,4,7},
        {2,3,4},
        {3,4,5},
        {4,2,6}
    };

    int n,m,i,j,k;
    int u[8],v[8],w[8];
    int first[6],next[8]; // first要比n的最大值大一，next要比m的最大值大1
    int dis[6] = {0},book[6] = {0};
    int que[101] = {0},head = 0,tail = 0;// 定义一个队列，并初始化
    int inf = 99999999; // 代表无穷大
    printf("读入顶点n 和边数m：");
    scanf("%d %d",&n,&m); // 5 个顶点, 7条边
    
    // 初始化dis 数组，dis 存储是0号顶点到其他顶点的路程
    for (i = 0; i < n; i ++) {
        dis[i] = inf;
        // 初始化book数组，初始化为0，刚刚开始都不在队列里面
        book[i] = 0;
        // 初始化first数组下标0 ~ n-1的值都为-1，表示 0~n-1都没有边
        first[i] = -1;
    }
    dis[0] = 0;
    
    

    
    // 读入边
    for (i = 0; i < m; i ++) {
        //printf("输入两个顶点 和他们之间的距离");
        //scanf("%d %d %d",&u[i],&v[i],&w[i]);
        // 不想输入，初始化定义好相关数据
        for (j = 0; j < 3; j ++) {
            if (j == 0) {
                u[i] = map[i][0];
            }
            if (j == 1) {
                v[i] = map[i][1];
            }
            if (j == 2) {
                w[i] = map[i][2];
            }
        }
        // 建立邻接表关键demo
        next[i] = first[u[i]];  // next[i]用于存储 编号为i的 下一条边的编号
        first[u[i]] = i;        // first[u[i]] 用于存储 顶点编号为 u[i]的 第一条边(顶点可能有多条边)的编号
        printf("%d %d %d \n",u[i],v[i],w[i]);
    }
    
    // 0号顶点入队列
    que[tail] = 0; tail ++;
    // 标记0号顶点已经入队
    book[0] = 1;
    
    while (head < tail) { // 队列不为空的时候循环
        printf("head ==+%d   tail ==%d\n",head,tail);
        k = first[que[head]];   // 当前需要处理的队首顶点
        while (k != -1) {// 扫描顶点所有的边
            
            if (dis[v[k]] > dis[u[k]] + w[k]) { // 判断是否松弛成功
                dis[v[k]] = dis[u[k]] + w[k]; // 更新顶点0 到 顶点v[k]的最短路程
                // 这里自所以需要使用book数组来标记，是为了节约时间，不然的话每次都需要在队列 从 head 到 tail扫一遍，很浪费时间
                if (book[v[k]] == 0) { // 判断v[k]是否已经加入到队列
                    
                    // 不在队列中，加入队列队尾
                    que[tail] = v[k];
                    tail ++;
                    book[v[k]] = 1; // 标记顶点v[k]已经入队
                    
                }
            }
            k = next[k]; // 继续循环  类似 for 循环里面 i++的效果一样
        }
        // 队首出队
        book[que[head]] = 0;// 取消标记
        head ++;
    }
    
    printf("输入0号顶点到其他顶点的最短距离是\n\n");
    for (i = 0; i < n; i ++) {
        printf("到顶点%d距离%d \n",i,dis[i]);
    }
    printf("\n");
    getchar();
    
    /**
     Bellman-Ford 队列优化总结
     初始将源点加入队列，每次 从 队首（head）里面取出一个点，并对其相邻的顶点做松弛处理，若松弛成功，且这个顶点不在队列之中，则吧他加入到对列，当前顶点处理结束之后，立刻将队首移出队列，并对下一个对首进进行重复操作，直至队列为空 算法结束。
     
     里面使用了一个book 数组来记录每一个顶点是否在队列里面，如果不使用这个book数组，只需要 吧队列que[head] 到 que[tail] 依次判断一次即可，但是这样的时间复杂度是O(N) ,而使用 book 之后的时间复杂度会下降到O(1)。
     
     使用队列优化Bellman-Ford 算法和之前学的 “广度优先搜索” 十分类似，不同的是，广度优先搜索在 队列出队后，通常不会再次重新进入队列，而这里一个顶点可能在出队后再次进入队列，也就是当一个顶点的最短路径估计值变短之后，需要对它所有的边进行松弛，这样才能保证相邻顶点的最短路程估计值同步更新。
     使用 Bellman-Ford 算法在最坏的情况下时间复杂度是O(NM),
     
     疑问 ：那么该算法如何判一个图是否有负权回路？
     思路： 可以根据顶点进入队列的次数来判断，如果某个顶点进入队列的次数超过n次，那么这个图有负权回路，自己想一想吧
     
     **/
    
    return 0;
}
